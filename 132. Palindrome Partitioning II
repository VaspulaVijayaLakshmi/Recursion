class Solution {
public:
    int minCount=INT_MAX;

    bool isPalindrome(string s){

        int l=0,r=s.size()-1;

        while(l<=r){

            if(s[l]!=s[r]) return false;
            l++;
            r--;
        }

        return true;
    }



    void minCut(string s,int i, int cuts ){

      if(i==s.size()){
        minCount = min(minCount, cuts-1);
        return ;
      }

      for(int j=i;j<s.size();j++){

       string sub = s.substr(i,j-i+1);

       if(isPalindrome(sub)){
          minCut(s,j+1,cuts+1);   
       }

      }

    }

    int minCut(string s) {
     
     minCut(s,0,0);
     return minCount;
        
    }
};















class Solution {
public:

    bool isPalindrome(string s){

        int l=0,r=s.size()-1;

        while(l<=r){

            if(s[l]!=s[r]) return false;
            l++;
            r--;
        }

        return true;
    }



But the first one cannot be memoized, if u want to memoize u need to write ti in 2nd approach only\




    int minCut(string s,int i){

      if(i==s.size()){
        return 0;
      }


      int minCount=INT_MAX;
      for(int j=i;j<s.size();j++){

       string sub = s.substr(i,j-i+1);

       if(isPalindrome(sub)){

                //   this is dfs
          int cuts = 1+ minCut(s,j+1); 

        //   once dfs completes, take min
          minCount = min(cuts,minCount);
       }

      }

      return minCount;

    }

    int minCut(string s) {
     
     return minCut(s,0)-1;
        
    }
};







MEMOIZATION 

MEMory LIMIT EXCEEDED


class Solution {
public:

    vector<int> dp;
     
    bool isPalindrome(string s){

        int l=0,r=s.size()-1;

        while(l<=r){

            if(s[l]!=s[r]) return false;
            l++;
            r--;
        }

        return true;
    }



    int minCut(string s,int i){

      if(i==s.size()){
        return 0;
      }

      if(dp[i] !=-1) return dp[i];


      int minCount=INT_MAX;
      for(int j=i;j<s.size();j++){

       string sub = s.substr(i,j-i+1);

       if(isPalindrome(sub)){

                //   this is dfs
          int cuts = 1+ minCut(s,j+1); 

        //   once dfs completes, take min
          minCount = min(cuts,minCount);
       }

      }

      return dp[i] = minCount;

    }

    int minCut(string s) {

        dp.resize(s.size(),-1);

    return  minCut(s,0)-1;
        
    }
};










//tabulation





class Solution {
public:
    bool palindrome(int i, int j, string&s){
        while(i<j){
            if(s[i]==s[j]){
                i++; j--;
            }
            else return false;
        }
        return true;
    }


    int minCut(string s) {
        int n = s.size();
        vector<int>dp(n+1, 0);

        for(int i=n-1; i>=0; i--){
            int ans = 1e9;
            for(int j=i; j<n; j++){
                
                if(palindrome(i, j, s)){
                    int cost = 1+dp[j+1];
                    ans = min(ans, cost);
                }
            }

            dp[i] = ans;
        }

        return dp[0]-1;
    }
};






 Example:
Let’s take s = "aab"
So n = 3, and dp is a size-4 array.

Step-by-step:
i = 2: (s[2] = 'b')
j = 2: s[2..2] = "b" is a palindrome 
→ cost = 1 + dp[3] = 1 + 0 = 1
→ dp[2] = 1

i = 1: (s[1] = 'a')
j = 1: s[1..1] = "a" is a palindrome 
→ cost = 1 + dp[2] = 1 + 1 = 2

j = 2: s[1..2] = "ab" - not palindrome

→ Minimum = 2, so dp[1] = 2

i = 0: (s[0] = 'a')
j = 0: s[0..0] = "a" is palindrome 
→ cost = 1 + dp[1] = 1 + 2 = 3

j = 1: s[0..1] = "aa" is palindrome 
→ cost = 1 + dp[2] = 1 + 1 = 2 ← better

j = 2: s[0..2] = "aab"  not palindrome

→ Minimum = 2, so dp[0] = 2

